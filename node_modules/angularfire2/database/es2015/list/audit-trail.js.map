{"version":3,"file":"audit-trail.js","sourceRoot":"","sources":["../../../../../src/database/list/audit-trail.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAG/C,OAAO,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAGhD,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,gBAAgB,CAAC;AAEtE,MAAM,2BAA2B,KAAoB,EAAE,UAA+B;IACpF,MAAM,CAAC,CAAC,MAAqB,EAAE,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,sBAAsB,CAC3E,UAAU,CAAC,SAAS,CAAC,iBAAiB,CACpC,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,CAC1B,CACF,CAAC;CACH;AAED,MAAM,qBAAqB,KAAoB,EAAE,MAAqB;IACpE,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,EAAE,MAAM,CAAC;SAC5C,IAAI,CACH,IAAI,CAAiB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC,GAAG,OAAO,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CACpE,CAAC;IACJ,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;CAC1C;AAOD,oBAAoB,KAAoB;IAItC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC;SAC7B,IAAI,CACH,GAAG,CAAC,IAAI,CAAC,EAAE;QAET,IAAI,aAAa,CAAC;QAElB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC3B,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;SACzC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,IAAI,EAAE,aAAa,EAAE,CAAC;KAChC,CAAC,CACH,CAAC;CACH;AAED,uBAAuB,KAAoB,EAAE,OAAqC;IAChF,MAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;IAClC,MAAM,CAAC,OAAO;SACX,IAAI,CACH,cAAc,CAAC,OAAO,CAAC,EAGvB,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,EAAE;QAExB,IAAI,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;QAEzC,MAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjD,MAAM,CAAC,EAAE,OAAO,EAAE,aAAa,EAAE,UAAU,EAAE,CAAA;KAC9C,CAAC,EAIF,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,EAGrE,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAC1B,CAAC;CACL","sourcesContent":["import { DatabaseQuery, ChildEvent, DatabaseSnapshot, AngularFireAction, SnapshotAction } from '../interfaces';\nimport { stateChanges } from './state-changes';\nimport { Observable } from 'rxjs';\nimport { DataSnapshot } from '@firebase/database-types';\nimport { fromRef } from '../observable/fromRef';\nimport { AngularFireDatabase } from '../database';\n\nimport { skipWhile, withLatestFrom, map, scan } from 'rxjs/operators';\n\nexport function createAuditTrail(query: DatabaseQuery, afDatabase: AngularFireDatabase) {\n  return (events?: ChildEvent[]) => afDatabase.scheduler.keepUnstableUntilFirst(\n    afDatabase.scheduler.runOutsideAngular(\n      auditTrail(query, events)\n    )\n  );\n}\n\nexport function auditTrail(query: DatabaseQuery, events?: ChildEvent[]): Observable<SnapshotAction[]> {\n  const auditTrail$ = stateChanges(query, events)\n    .pipe(\n      scan<SnapshotAction>((current, action) => [...current, action], [])\n    );\n  return waitForLoaded(query, auditTrail$);\n}\n\ninterface LoadedMetadata {\n  data: AngularFireAction<DataSnapshot>;\n  lastKeyToLoad: any;\n}\n\nfunction loadedData(query: DatabaseQuery): Observable<LoadedMetadata> {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, 'value')\n  .pipe(\n    map(data => {\n      // Store the last key in the data set\n      let lastKeyToLoad;\n      // Loop through loaded dataset to find the last key\n      data.payload.forEach(child => {\n        lastKeyToLoad = child.key; return false;\n      });\n      // return data set and the current last key loaded\n      return { data, lastKeyToLoad };\n    })\n  );\n}\n\nfunction waitForLoaded(query: DatabaseQuery, action$: Observable<SnapshotAction[]>) {\n  const loaded$ = loadedData(query);\n  return loaded$\n    .pipe(\n      withLatestFrom(action$),\n      // Get the latest values from the \"loaded\" and \"child\" datasets\n      // We can use both datasets to form an array of the latest values.\n      map(([loaded, actions]) => {\n        // Store the last key in the data set\n        let lastKeyToLoad = loaded.lastKeyToLoad;\n        // Store all child keys loaded at this point\n        const loadedKeys = actions.map(snap => snap.key);\n        return { actions, lastKeyToLoad, loadedKeys }\n      }),\n      // This is the magical part, only emit when the last load key\n      // in the dataset has been loaded by a child event. At this point\n      // we can assume the dataset is \"whole\".\n      skipWhile(meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1),\n      // Pluck off the meta data because the user only cares\n      // to iterate through the snapshots\n      map(meta => meta.actions)\n    );\n}\n"]}